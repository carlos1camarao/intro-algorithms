%!TEX encoding = ISO-8859-1
\chapter{\colorbox{cyan}{Estruturas de Dados Básicas}}
\label{estruturas-de-dados-basicas}

Este capítulo aborda listas e árvores, suas representações em um computador e
operações básicas sobre essas estruturas de dados.

\section{Listas}
\label{listas}

Uma lista é uma estrutura de dados comumente usada em computação e pode ser definida recursivamente como a seguir.  Uma lista de elementos de
determinado tipo \inh{t} é ou i) {\em vazia} ou ii) constituída de um elemento de tipo \inh{t} e um uma lista de elementos do mesmo tipo \inh{t} (denominada {\em cauda} ou resto da lista).

Em uma linguagem como Haskell, que provê suporte à definição de tipos
de dados recursivos, o tipo lista pode ser definido como:

\begin{center}
\begin{tabular}{l}
\begin{hask}{List,Nil,Cons}
data List a = Nil | Cons a (List a)
\end{hask}
\end{tabular}
\end{center}

O tipo de dado \inh{\List a} é um tipo recursivo, sendo \inh{Nil} e \inh{Cons} os construtores de valores desse tipo. Além disso, \inh{\List a} é um tipo {\em polimórfico}: a variável de tipo \inh{a} pode ser instanciada para um tipo \inh{t} qualquer, permitindo assim a definição de listas com elementos de desse tipo \inh{t}. Por exemplo, \inh{(Cons 1 (Cons 2 (Cons 3 Nil)))} é uma lista de tipo \inh{List Int} e \inh{(Cons True (Cons False Nil))} tem tipo \inh{List Bool}. 

A linguagem Haskell provê uma notação especial para a criação de valores de tipo lista: \inh{[]}  é usado em lugar de \inh{Nil}, e o construtor infixado \inh{(:)}, associativo à direita, em lugar de \inh{Cons}. Por exemplo, a lista \inh{Cons 1 (Cons 2 (Cons 3 Nil))} seria representada como \inh{(1:2:3:[]}. 
Além disso, uma lista pode ser representada simplesmente escrevendo-se os seus elementos da lista entre colchetes, separados por vírgulas. Ou seja, a lista \inh{\inh{(1:2:3:[]}} pode ser escrita, mais simplesmente, como \inh{[1,2,3]}. 

Em linguagens como \C, uma lista pode ser representada por meio de {\em registros} (também chamados de  "estruturas", em \C) e {\em ponteiros\/} (ou apontadores), tal como ilustrado no exemplo a seguir, que define uma lista de elementos de tipo \ina{int}. Linguagens como \C, que não provêm suporte para polimorfismo, requerem a definição de tipos lista distintos para cada tipo particular de elementos. 

\begin{center}
\begin{tabular}{l}
\begin{alg}{ListaDeInteiros}
struct ListaDeInteiros
   int elem; 
   struct ListaDeInteiros *r;
\end{alg}
\end{tabular}
\end{center}

Uma definição de registro, em \C, é introduzida pela palavra-chave \ina{struct}, seguida do nome do registro -- neste caso, \ina{ListaDeInteiros}. O registro possui dois campos: um campo de tipo \ina{int} e nome \ina{elem}, e um campo de nome \ina{r}, que é um ponteiro para valores do próprio tipo \ina{ListaDeInteiros}. 
 
A manipulação de valores de tipo lista em \C\ é bem mais trabalhosa. A falta de suporte para definição e uso de tipos recursivos e polimórficos torna a programação mais difícil e demorada e o código menos legível e mais sujeito a repetições e a ocorrências de erros. Por exemplo, para criar um valor de tipo \ina{ListaDeInteiros}, com os elementos \inh{1,2,3},  é necessário código como o seguinte:
\index{\ina{ListaDeInteiros}}

\begin{center}
\begin{tabular}{l}
\begin{alg}{ListaDeInteiros}
struct ListaDeInteiros *p =
   malloc(sizeof(struct ListaDeInteiros))
   p->elem = 1;       p->r = malloc(sizeof(struct ListaDeInteiros))
   p->r->elem = 2;    p->r->r = malloc(sizeof(struct ListaDeInteiros))
   p->r->r->elem = 3; p->r->r->r = NULL
\end{alg}
\end{tabular}
\end{center}

Em \Haskell, o acesso a um valor \inh{v}, em uma lista \inh{x}, requer acesso a
todos os elementos anteriores a \inh{v} em \inh{x}. De fato, a representação interna de listas definidas em \Haskell é feita por meio de ponteiros, mas a manipulação de ponteiros é gerada automaticamente pelo compilador da linguagem, de acordo com o código do programa, em vez de ser feita diretamente pelo programador.

Uma maneira alternativa de representar listas é por meio de {\em arranjos}, 
especialmente em uma linguagem (como \C) que não provê suporte a
manipulação de valores de estruturas de dados recursivas. Utilizando essa forma de representação, a lista fica limitada a um número máximo de elementos, já que a defição de uma arranjo requer que o número de elementos do mesmo seja especificado a priori.

\subsection{Pesquisa}
\label{pesquisa-em-lista}

Em computação, {\em pesquisar\/} em geral significa determinar se um
dado elemento está presente ou não em uma estrutura de dados. As
subseções seguintes tratam de operações de pesquisa, inserção e
remoção de elementos de listas, de acordo com a forma com que listas
são representadas.

Em ambos os casos apresentados abaixo, a pesquisa em uma lista de $n$
elementos tem complexidade $O(n)$ no pior caso, pois envolve, possivelmente, comparação com cada elemento da lista.

\subsubsection{Versão funcional}

A função \inh{elem}, que determina se um dado valor é elemento de uma lista dada, pode ser definida como a seguir:
\index{\inh{elem}}

\begin{center}
\begin{tabular}{l}
\begin{hask}{elem}
elem :: Eq a => a -> a -> Bool
elem a []    = False
elem a (b:x) = (a == b) || elem a x
\end{hask}
\end{tabular}
\end{center}

O tipo de \inh{elem}, em \Haskell, é um tipo {\em polimórfico restrito\/}: a restrição ({\em constraint\/}) (\inh{Eq a}) indica que a variável de tipo \inh{a}
não pode ser instanciada para qualquer tipo, mas apenas para um tipo
que é membro da classe de tipos \inh{Eq}, ou seja, no caso, apenas para um
tipo para o qual exista definida uma operação de igualdade \inh{(==)}, para
valores desse tipo. É um erro de tipo chamar a função \inh{elem} com um argumento de um tipo para o qual não é definida comparação de igualdade.

\HRule
{\em Nota\/}: 

A função \inh{elem}, de fato, faz parte do módulo \Prelude, importado
automaticamente por todos os módulos de programas \Haskell, sem necessidade de comando ou cláusula explícita de importação. A definição de \inh{elem} no \Prelude\ é diferente da apresentada acima, e usa outras funções também definidas no \Prelude, como \inh{mmap} e \inh{foldr}, que são ferramentas importantes para definição de outras funções em Haskell. A definição de \inh{elem} contida no \Prelude\ é apresentada a seguir:

\begin{center}
\begin{tabular}{l}
\begin{hask}{foldr,mmap,and,or,any,all,elem}
foldr  :: (a -> b -> b) -> b -> [a] -> b
foldr f z []    =  z
foldr f z (a:x) =  f a (foldr f z x) 

mmap :: (a -> b) -> [a] -> [b]
mmap §{\tt \_}§  []   = []
mmap f (a:x) = f a : mmap f x 

and, or :: [Bool] -> Bool
and =  foldr (&&) True
or   =  foldr (||) False 

any, all :: (a -> Bool) -> [a] -> Bool
any p =  or . map p
all p =  and . map p 

elem :: (Eq a) => a -> [a] -> Bool
elem a = any (== a)
\end{hask}
\end{tabular}
\end{center}

\HRule

\subsubsection{Versão imperativa}

A versão imperativa de \ina{elem} definida a seguir recebe como argumento o valor a ser pesquisado, denotado pelo parâmetro \ina{a}, juntamente com um apontador para uma lista (de tipo \ina{ListaDeInteiros}), denotado pelo parâmetro \ina{l}. O algoritmo retorna retorna um apontador para o elemento da lista \ina{l} que é igual a \ina{a}, caso o argumento esteja presente na lista, e retorna \ina{NULL} em caso contrário.
\index{\ina{elem}}

\begin{center}
\begin{tabular}{l}
\begin{alg}{elem}
elem (a, l) 
   while (l != NULL && l->elem != a) l = l->r
   return l
\end{alg}
\end{tabular}
\end{center}

\subsection{Inserção}
\label{insercao-em-lista}

Inserir um elemento no início de uma lista é uma operação de
complexidade $O(1)$.

\subsubsection{Versão funcional}

A inserção de um elemento no início da lista é feita simplesmente, por meio do construtor de lista \inh{(:)}, ou seja:
\index{\inh{insert}}

\begin{center}
\begin{hask}{insert}
insert = (:)
\end{hask}
\end{center}

\subsubsection{Versão imperativa}

Na versão imperativa, é alocado um novo registro, de tipo \ina{ListaDeInteiros},
para armazenar o novo valor a ser inserido na lista, sendo retornada a lista resultante dessa operação.
\index{\ina{insert}}

\begin{center}
\begin{tabular}{l}
\begin{alg}{insert}
insert (a, l)
   p = malloc(sizeof(struct ListaDeInteiros))
   p->elem = a
   p->r = l
   return p
\end{alg}
\end{tabular}
\end{center}

\subsection{Remoção}
\label{remocao-de-lista}

Remover um elemento de uma lista é uma operação de complexidade $O(n)$
no pior caso, pois é necessário procurar o elemento a ser removido.

A Seção \ref{lista-duplamente-encadeada} redefine o tipo de lista
encadeada para uma versão de listas duplamente encadeadas, e reescreve
as funções \ina{elem} e \ina{insert}, para definir \ina{delete} por meio de uma
chamada à função \ina{elem}, seguida de chamada a \ina{insert}.

\subsubsection{Versão funcional}

A versão funcional cria uma nova lista, que não tem o elemento
passado como parâmetro:
\index{\inh{delete}}

\begin{center}
\begin{tabular}{l}
\begin{hask}{delete}
delete :: Eq a => a -> [a] -> [a]
delete §{\tt \_}§ [] = []
delete a (b:x)
   | a == b    = x
   | otherwise = b:delete a x
\end{hask}
\end{tabular}
\end{center}

\subsubsection{Versão imperativa}

A versão imperativa de \ina{delete}, apresentada a seguir, não cria uma nova lista: usa um ponteiro -- \ina{prev} -- para percorrer a lista até encontrar o elemento a ser removido e, quando este é encontrado, modifica a estrutura de encadeamento da lista, removendo este elemento. 

\begin{center}
\begin{tabular}{l}
\begin{alg}{delete}
delete (a, l) 
   struct ListaDeInteiros *prev = NULL;  
   *p = l
   while (p != NULL && p->elem != a)
      prev = p
      p = p->r
      if (prev == NULL) 
         return l->r
      else { prev->r = p->r; return l }
\end{alg}
\end{tabular}
\end{center}
             

\subsection{Lista duplamente encadeada}
\label{lista-duplamente-encadeada}

\ldots \ldots .....

\subsection{Pilha}
\label{pilha}

Uma estrutura de dados \ina{Pilha} caracteriza-se pelo fato de que as operações de inserção, acesso e remoção de elementos são feitas em apenas
um de seus lados (ou extremidades). Essa política de uso é comumente  chamada LIFO (do inglês, {\em last-in first-out\/}: o último a ser inserido é o primeiro a ser removido da pilha. A implementação de uma \ina{Pilha} inclui as  com as operações: i) criar pilha vazia, ii) empilhar elemento, iii) desempilhar elemento, iv) obter elemento do topo da pilha, e v) testar se pilha está vazia. 

\subsubsection{Versão funcional}
\index{\inh{Pilha}}
Em \Haskell, a implementação de \inh{Pilha} é obtida diretamente das operações definidas sobre listas, isto é:

\begin{center}
\begin{tabular}{l}
\begin{hask}{vazia,empilhar,desempilhar,topo,estaVazia}
vazia = []
empilhar = (:)
desempilhar (§{\tt \_}§:x) = x
topo (a:§{\tt \_}§) = a
estaVazia = null
\end{hask}
\end{tabular}
\end{center}
                  
Em geral, vamos procurar simplificar o código de nossos programas,
não tratando casos de erro, na maioria das vezes, por motivos didáticos. Entretanto, em programas completos não podemos esquecer de tratar todos os casos possíveis para os dados de entrada. Um módulo em Haskell que trata
todos esses casos possíveis para os dados de entrada das operações
acima é mostrado na Figura \ref{fig-Pilha}.

O módulo \inh{Pilha} implementa o que é chamado em computação de um {\em tipo abstrato de dados\/}, que é um tipo com operações de criação,
modificação e consulta sobre valores desse tipo. Por exemplo, \inh{vazia} é uma operação de criação (nesse caso, a única);
\inh{empilhar} e \inh{desempilhar} são operações de modificação; \inh{topo} e \inh{estaVazia} são operações de consulta. 

Em uma definição de um tipo abstrato de dados, a definição de tipo e das operações (para criação, modificação e consulta) sobre valores
do tipo devem ser contidas em um mesmo trecho de programa (em geral,
um módulo), e a representação usada não é ``visível'' para quem usa valores do tipo. Ou seja, um tipo abstrato é constituído de um tipo, munido de um conjunto de operações sobre valores desse tipo. Qualquer outra operação sobre valores do tipo apenas pode ser implementada por meio dessas operações previamente definidas.

Para definir um tipo abstrato \inh{Pilha}, em \Haskell, usamos uma definição de um novo tipo, introduzida pela palavra-chave \inh{newtype}. O tipo \inh{Pilha} possui um único construtor de valores \inh{mkPilha} (de mesmo nome do construtor de tipo). Esse mecanismo é usado para ocultar a representação do tipo abstrato: o construtor de  que não é exportado pelo módulo em que o tipo é definido: o construtor de valores \inh{mkPilha} não é exportado, apenas o construtor de tipos \inh{Pilha}. Para melhor legibilidade, definimos também o tipo de cada uma das funções. Veja Figura \ref{fig-Pilha}.
\end{document}

\begin{figure}

\begin{center}
\begin{tabular}
\begin{hask}{Pilha,vazia,empilhar,desempilhar,topo,estaVazia}
module Pilha (Pilha, vazia, empilhar, desempilhar, topo, estaVazia) where
   newtype Pilha a = mkPilha [a] 

vazia :: Pilha $a
vazia = mkPilha []

empilhar :: a -> Pilha a -> Pilha a
empilhar e (mkPilha p) = Pilha (e:p)

desempilhar :: Pilha a -> Pilha a
desempilhar (mkPilha []) = error "Função desempilhar chamada com pilha vazia"
desempilhar (mkPilha (§{\tt \_}§:p)) = mkPilha p

topo:: Pilha a -> a
topo (mkPilha [])   = error "Função topo chamada com pilha vazia"
topo (mkPilha (e:§{\tt \_}§)) = e 

estaVazia:: Pilha a -> Bool
estaVazia (mkPilha $p$) = null p
\end{hask}
\end{tabular}
\end{center}

\label{fig-Pilha}
\caption{Tipo abstrato \Pilha\ em Haskell}
\end{figure}



\subsubsection{Versão imperativa}

Considerando \pilha\ como um registro com campos \topo\ e \elems,
sendo \elems\ um arranjo de $n$ elementos --- indexado de $0$ a {\tt
  $n$-1} --- e \topo\ uma variável inteira que indica o índice do
último elemento inserido, as operações em uma pilha podem ser
implementadas como a seguir (desconsiderando casos de erro:
desempilhar de uma pilha vazia e empilhar em uma pilha cheia).

\newcommand{\nome}{{\it nome\/}}

O comando \with\ serve para tornar os nomes de campos de um registro
visíveis: \with\ $r$ evita que se tenha que prefixar os nomes dos
campos do registro $r$ com o registro (\nome\ pode ser usado em vez de
{\tt $r$.\nome}).

\progb{
  \vazia\ (\pilha) \{ \pilha.\topo\ = -1 \}\\ \ \hspace*{.2cm} \\
  \empilhar\ (\eelem, \pilha) \\
      \hspace*{.2cm} \with\ \pilha\  \\
        \hspace*{1cm} \topo\ $\leftarrow$ \topo\ + 1\\
        \hspace*{1cm} \elems[\topo] $\leftarrow$ \eelem\\ \ \hspace*{.2cm} \\
  \desempilhar\ (\pilha) \\ 
      \hspace*{.2cm} \with\ \pilha\ \{ \topo\ $\leftarrow$ \topo\ - 1 \} \\ \ \hspace*{.2cm} \\
  \topo\ (\pilha) \{ \with\ \pilha\ \{ \return\ \elems[\topo] \} \}\\ \ \hspace*{.2cm} \\ 
  \estaVazia\ (\pilha) \{ \return\ \pilha.\topo\ == -1 \}
 }

\subsection{Fila}
\label{fila}

Em uma {\em fila} a inserção é feita de um lado e a remoção é feita do
outro lado da estrutura de dados. Isso implica em uma política algumas
vezes chamada de FIFO ({\em first-in first-out\/}: o primeiro a ser
inserido é o primeiro a ser removido da fila.

Uma fila, com operações de i) criar fila vazia, ii) entrar (inserir
elemento) na fila, iii) sair (tirar elemento) da fila, iv) obter
elemento do início da fila, e v) testar se fila está vazia, pode ser
implementada como a seguir.

\subsubsection{Versão funcional}

\newcommand{\frente}{{\it frente\/}}
\newcommand{\tras}{{\it trás\/}}
\newcommand{\fila}{{\it fila\/}}

Não é eficiente fazer acesso ao último elemento de uma lista em
Haskell. A implementação padrão de filas por meio de listas usa assim
duas listas, \frente\ e \tras. Elementos entram na lista \tras\ e saem
na lista \frente.

A função \fila\ é usada para garantir o invariante de que se
\frente\ está vazia, então \tras\ está vazia (e portanto a fila está
vazia).

\newcommand{\reverse}{{\it reverse\/}}
\newcommand{\sair}{{\it sair\/}}
\newcommand{\entrar}{{\it entrar\/}}
\newcommand{\inicio}{{\it início\/}}

\progb{\vazia\ = ([],[])\\ \ \hspace*{.2cm} \\
      \entrar\ $e$ (\frente,\tras) = \fila\ (\frente, $e$ : \tras)\\ \ \hspace*{.2cm} \\
      \fila\ ([], \tras) = (\reverse\ \tras, [])\\
      \fila\ $f$        = $f$\\ \ \hspace*{.2cm} \\
      \sair\ ($e$:\frente, \tras) = (\frente,\tras)\\ \ \hspace*{.2cm} \\
      \estaVazia\ (\frente,\_) = \null\ \frente\\ \ \hspace*{.2cm} \\
      \inicio\ ($e$:\frente,\_) = $e$
     }

\subsubsection{Versão imperativa}
\label{fila-imperativa}

\newcommand{\fim}{{\it fim\/}}

Considerando \fila\ como um registro com campos \inicio, \fim\ e
\elems, sendo \elems\ um arranjo de $n$ elementos --- indexado de $0$
a {\tt $n$-1}.  Os índices do primeiro e do último elementos inseridos
são armazenados respectivamente nas variáveis \inicio\ e \fim. 

A fila está vazia quando {\tt \inicio\ == \fim}. A fila está cheia
quando {\tt \inicio\ == \fim\ + 1}, isto é, a fila é circular: o
índice {\tt 0} segue o índice {\tt $n$-1}. 

As operações em uma fila podem ser implementadas como a seguir,
desconsiderando casos de erro: sair de uma fila vazia e entrar em uma
fila cheia. O operador {\tt \%} é usado para retornar o resto da
divisão do primeiro operando pelo segundo.

\progb{
  \vazia\ (\fila) \{ \with\ \fila\ \{ \inicio\ = \fim\ = 0 \} \} \\ \ \hspace*{.2cm} \\
  \entrar\ (\eelem, \fila) \\
      \hspace*{.2cm} \with\ \fila\  \\
          \hspace*{1cm} \elems[\fim] $\leftarrow$ \eelem\\
          \hspace*{1cm} \fim\ $\leftarrow$ (\fim\ + 1) \% $n$\\ \ \hspace*{.2cm} \\
  \sair\ (\fila) \\
      \hspace*{.2cm} \with\ \fila\ \{ \inicio\ $\leftarrow$ (\inicio\ + 1) \% $n$ \}\\ \ \hspace*{.2cm} \\
  \inicio\ (\fila) \{ \with\ \fila\ \{ \return\ \elems[\inicio] \} \}\\ \ \hspace*{.2cm} \\
  \estaVazia\ (\pilha) \{ \with\ \fila\ \{ \return\ \inicio\ == \fim\ \} \} 
 }

\input{arvores}

